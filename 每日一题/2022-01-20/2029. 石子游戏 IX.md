# [2029. 石子游戏 IX](https://leetcode-cn.com/problems/stone-game-ix/)

Alice 和 Bob 再次设计了一款新的石子游戏。现有一行 n 个石子，每个石子都有一个关联的数字表示它的价值。给你一个整数数组 stones ，其中 stones[i] 是第 i 个石子的价值。

Alice 和 Bob 轮流进行自己的回合，Alice 先手。每一回合，玩家需要从 stones 中移除任一石子。

如果玩家移除石子后，导致 所有已移除石子 的价值 总和 可以被 3 整除，那么该玩家就 输掉游戏 。
如果不满足上一条，且移除后没有任何剩余的石子，那么 Bob 将会直接获胜（即便是在 Alice 的回合）。
假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。

 

**示例 1：**

输入：stones = [2,1]

输出：true

解释：游戏进行如下：

- 回合 1：Alice 可以移除任意一个石子。
- 回合 2：Bob 移除剩下的石子。 已移除的石子的值总和为 1 + 2 = 3 且可以被 3 整除。因此，Bob 输，Alice 获胜。

**示例 2：**

输入：stones = [2]

输出：false

解释：Alice 会移除唯一一个石子，已移除石子的值总和为 2 。 

由于所有石子都已移除，且值总和无法被 3 整除，Bob 获胜。

**示例 3：**

输入：stones = [5,1,2,4,3]

输出：false

解释：Bob 总会获胜。其中一种可能的游戏进行方式如下：

- 回合 1：Alice 可以移除值为 1 的第 2 个石子。已移除石子值总和为 1 。
- 回合 2：Bob 可以移除值为 3 的第 5 个石子。已移除石子值总和为 = 1 + 3 = 4 。
- 回合 3：Alices 可以移除值为 4 的第 4 个石子。已移除石子值总和为 = 1 + 3 + 4 = 8 。
- 回合 4：Bob 可以移除值为 2 的第 3 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 = 10.
- 回合 5：Alice 可以移除值为 5 的第 1 个石子。已移除石子值总和为 = 1 + 3 + 4 + 2 + 5 = 15. Alice 输掉游戏，因为已移除石子值总和（15）可以被 3 整除，Bob 获胜。

**提示：**

- 1 <= stones.length <= 105
- 1 <= stones[i] <= 104

## 题解

### 1、博弈

这种玩游戏的题一般都是博弈问题，我们可以从游戏胜负条件中发现切入点。

当玩家移除石头后，已移除石头价值总和若能被3整除，则该玩家输掉游戏。因此我们只关心每块石头的价值对3取余的结果。这里把三种不同取余结果的石头称为类型0、类型1和类型2。

对于玩家A，若移除了一颗类型2石头，那么玩家B必然就不能移除类型1石头。以此类推。

对于这类博弈游戏，一定要看”最后一步“，最后一步往往能决定玩家的最佳策略。

试想，如果玩家A在某一步时，发现自己移除类型1石头后就正好达到了失败条件，那么他会选择什么？只能选择移除类型0。类型2同理。

因此在游戏的一开始，两名玩家的最优策略都应该是尽可能地移除类型0石头，这样已移除石头价值总和本质上不会受到影响。

此时引出第一个关键点：

- 若类型0石头数为偶数，则等价于没有类型0的石头，因为两位玩家两两移除类型0石头
- 若类型0石头数为奇数，则等价于只有1颗类型0的石头

当处理完全部类型0的石头后，就只剩下类型1和类型2这两种类型的石头了：

- 如果玩家A先手移除类型1，那么两位玩家移除石头的顺序只能是：112121212121
- 如果玩家A先手移除类型2，那么两位玩家移除石头的顺序只能是：221212121212

可以发现，先移除类型1或类型2，两位玩家的移除顺序本质上是一样的，设此时剩下的两种石头为类型a和类型b

玩家移除石头的顺序可以统一记作：aabababab

此时可以归纳玩家A的获胜条件：

- 类型a只有1个且类型b至少有1个
- 类型a至少有2个且不能比类型b多

注意这里我定义类型a既可以指代类型1也可以指代类型2，即归纳的获胜条件其实包含4种情况。

```python
class Solution:
    def stoneGameIX(self, stones: List[int]) -> bool:
        # 统计对于3的不同余数的石头数
        cnt0, cnt1, cnt2 = 0, 0, 0
        for stone in stones:
            if stone % 3 == 0:
                cnt0 += 1
            elif stone % 3 == 1:
                cnt1 += 1
            else:
                cnt2 += 1
        # 根据数量关系判断胜负
        if cnt0 % 2 == 0:
            return cnt1 >= 1 and cnt2 >= 1
        else:
            return cnt1 - cnt2 > 2 or cnt2 - cnt1 > 2
```

我做这道题时，能感觉出大概是用博弈的方法考虑，但是”应该从最后一步“来切入，这一点太久没做这类题，有些忘了。

主要还是因为这类题比较烧脑，我不太擅长吧。