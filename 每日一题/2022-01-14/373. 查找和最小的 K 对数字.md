# [373. 查找和最小的 K 对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)

给定两个以 升序排列 的整数数组 nums1 和 nums2 , 以及一个整数 k 。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。

请找到和最小的 k 个数对 (u1,v1),  (u2,v2)  ...  (uk,vk) 。

 

**示例 1:**

输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3

输出: [1,2],[1,4],[1,6]

解释: 返回序列中的前 3 对数：

​     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]

**示例 2:**

输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2

输出: [1,1],[1,1]

解释: 返回序列中的前 2 对数：

​     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]

**示例 3:**

输入: nums1 = [1,2], nums2 = [3], k = 3 

输出: [1,3],[2,3]

解释: 也可能序列中所有的数对都被返回:[1,3],[2,3]

**提示:**

- 1 <= nums1.length, nums2.length <= 105
- -109 <= nums1[i], nums2[i] <= 109
- nums1 和 nums2 均为升序排列
- 1 <= k <= 1000

## 题解

### 1、多路复用

本题的一个方法当然是算出并记录全部数对的和，然后根据值进行排序，筛选出前 k 小的数对，但是这种方法涉及太多无用计算。

另一个比较好的方法是多路复用，我们大致写出所有数对的组合：

> (0, 0), (0, 1), ... , (0, n - 1)
>
> (1, 0), (1, 1), ... , (1, n - 1)
>
> ...
>
> (m - 1, 0), (m - 1, 1), ... , (m - 1, n - 1)

这 m 行序列，均满足从左往右依次增大的规律，可以看成是“多路”，一开始我们将这多路的路首元素加入堆中，每一次循环都从堆中弹出堆顶元素，即最小数对，然后将弹出元素所在这一路的下一个数对加入堆中，然后继续下一次循环直到数对个数达到 k 或者所有数对都处理完。

```python
class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        # 初始化小根堆
        hp = []
        m, n = len(nums1), len(nums2)
        # 初始化结果集
        res = []
        # 记录nums1和nums2是否交换，若需要则进行交换
        flag = (m >= n)
        if flag:
            nums1, nums2, m, n = nums2, nums1, n, m
        # 将多路复用的路首元素加入堆中
        for i in range(min(m, k)):
            heapq.heappush(hp, (nums1[i] + nums2[0], i, 0))
        # 不断弹出堆顶元素
        while len(res) < k and hp:
            # 弹出堆顶元素，和最小的数对
            _, a, b = heapq.heappop(hp)
            res.append((nums2[b], nums1[a]) if flag else (nums1[a], nums2[b]))
            # 将当前路的下一个数对加入栈中
            if b + 1 < n:
                heapq.heappush(hp, (nums1[a] + nums2[b + 1], a, b + 1))
        return res
```

nums1和nums2可能有长短之分，而堆中元素数量是和多路复用的“路数”相等的，路越多，同一时间堆中元素就越多，且最关键的是新元素入堆后，堆重新堆化的开销的O(loglen(堆)) = O(log路数)，所以路数越少，我们堆化的开销就越少。

基于上述分析，我们需要找一个让路数尽可能少的排列方法，这里很简单，就是让nums1总是那个元素数较少的数组，这样可以保证

> (0, 0), (0, 1), ...
>
> (1, 0), (1, 1), ...
>
> (2, 0), (2, 1), ...
>
> ...
>
> (m - 1, 0), (m - 1, 1), ...

这种情况的路数比下面这种情况的路数要少

> (0, 0), (1, 0), ...
>
> (0, 1), (1, 1), ...
>
> (0, 2), (1, 2), ...
>
> ...
>
> (0, m - 1), (1, m - 1), ...

算是这道题的一个小优化了。

题外话：这道题非常像字节面试时常问的那道赛马智力题，大概就是总共有25匹马，给你几个赛道，无法记录每匹马跑完赛道需要的时间，但可以记录马赛跑的排名，最后问你最少多少次可以找出跑得最快的5/6/7匹马，其他也有64匹马8赛道的版本，具体可以在网上搜索“字节智力题”之类的关键词，这道题非常有名。

